#!/usr/bin/env python3
"""
Action server for navigating to predefined locations.
Reads locations from the location file and publishes goals to Nav2.
"""

import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from nav2_msgs.action import NavigateToPose
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from action_msgs.msg import GoalStatus
from butler_bot.action import NavigateToLocation  # type: ignore  # Generated by rosidl, available after build
import os


class LocationManager:
    """Manages location poses loaded from file."""
    
    def __init__(self, location_file_path, logger=None):
        self.locations = {}
        self.logger = logger
        self.load_locations(location_file_path)
    
    def log_warn(self, msg):
        if self.logger:
            self.logger.warn(msg)
        else:
            print(f"WARN: {msg}")
    
    def load_locations(self, file_path):
        """Parse location file and extract poses."""
        if not os.path.exists(file_path):
            self.log_warn(f"Location file not found: {file_path}")
            return
        
        with open(file_path, 'r') as f:
            lines = f.readlines()
        
        current_location = None
        pose_data = {}
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            
            # Check if this is a location name
            if 'home_pose' in line.lower():
                if current_location and pose_data:
                    self.locations[current_location] = self._create_pose(pose_data)
                current_location = 'home_pose'
                pose_data = {}
            elif 'kitchen' in line.lower() and 'pose' in line.lower():
                if current_location and pose_data:
                    self.locations[current_location] = self._create_pose(pose_data)
                current_location = 'kitchen'
                pose_data = {}
            elif 'tabel 1' in line.lower() or ('table 1' in line.lower() and i > 30):  # table 1 appears later
                if current_location and pose_data:
                    self.locations[current_location] = self._create_pose(pose_data)
                current_location = 'table_1'
                pose_data = {}
            elif 'table 2' in line.lower():
                if current_location and pose_data:
                    self.locations[current_location] = self._create_pose(pose_data)
                current_location = 'table_2'
                pose_data = {}
            elif 'table 3' in line.lower():
                if current_location and pose_data:
                    self.locations[current_location] = self._create_pose(pose_data)
                current_location = 'table_3'
                pose_data = {}
            
            # Parse translation - format: "- Translation: [x, y, z]" (can be on same or next line)
            if 'Translation:' in line:
                # Check if values are on same line
                if '[' in line:
                    trans_line = line
                elif i + 1 < len(lines):
                    trans_line = lines[i + 1].strip()
                else:
                    trans_line = ""
                
                # Extract values between brackets
                if '[' in trans_line:
                    start = trans_line.find('[')
                    end = trans_line.find(']')
                    if start != -1 and end != -1:
                        coords_str = trans_line[start+1:end]
                        try:
                            coords = [float(x.strip()) for x in coords_str.split(',')]
                            if len(coords) >= 2:
                                pose_data['x'] = coords[0]
                                pose_data['y'] = coords[1]
                                pose_data['z'] = coords[2] if len(coords) > 2 else 0.0
                        except ValueError:
                            pass
            
            # Parse quaternion - format: "- Rotation: in Quaternion (xyzw) [x, y, z, w]" (can be on same or next line)
            if 'Rotation: in Quaternion (xyzw)' in line:
                # Check if values are on same line
                if '[' in line:
                    quat_line = line
                elif i + 1 < len(lines):
                    quat_line = lines[i + 1].strip()
                else:
                    quat_line = ""
                
                # Extract values between brackets
                if '[' in quat_line:
                    start = quat_line.find('[')
                    end = quat_line.find(']')
                    if start != -1 and end != -1:
                        quat_str = quat_line[start+1:end]
                        try:
                            quat = [float(x.strip()) for x in quat_str.split(',')]
                            if len(quat) >= 4:
                                pose_data['qx'] = quat[0]
                                pose_data['qy'] = quat[1]
                                pose_data['qz'] = quat[2]
                                pose_data['qw'] = quat[3]
                        except ValueError:
                            pass
            
            i += 1
        
        # Add last location
        if current_location and pose_data:
            self.locations[current_location] = self._create_pose(pose_data)
    
    def _create_pose(self, pose_data):
        """Create a PoseStamped from parsed data."""
        pose = PoseStamped()
        pose.header.frame_id = 'map'
        
        if 'x' in pose_data:
            pose.pose.position.x = pose_data['x']
            pose.pose.position.y = pose_data['y']
            pose.pose.position.z = pose_data.get('z', 0.0)
        
        if 'qx' in pose_data:
            pose.pose.orientation.x = pose_data['qx']
            pose.pose.orientation.y = pose_data['qy']
            pose.pose.orientation.z = pose_data['qz']
            pose.pose.orientation.w = pose_data['qw']
        
        return pose
    
    def get_location(self, location_name):
        """Get pose for a location name."""
        # Normalize location name
        name = location_name.lower().replace(' ', '_')
        
        # Handle variations
        if 'home' in name:
            name = 'home_pose'
        elif 'kitchen' in name:
            name = 'kitchen'
        elif 'table1' in name or 'table_1' in name:
            name = 'table_1'
        elif 'table2' in name or 'table_2' in name:
            name = 'table_2'
        elif 'table3' in name or 'table_3' in name:
            name = 'table_3'
        
        return self.locations.get(name)
    
    def list_locations(self):
        """Return list of available location names."""
        return list(self.locations.keys())


class NavigateToLocationActionServer(Node):
    """Action server for navigating to predefined locations."""
    
    def __init__(self):
        super().__init__('navigate_to_location_action_server')
        
        # Initialize location manager
        location_file = os.path.join(
            os.path.expanduser('~'),
            'Documents',
            'location_for_butler_bot'
        )
        self.location_manager = LocationManager(location_file, self.get_logger())
        
        # Log available locations
        locations = self.location_manager.list_locations()
        self.get_logger().info(f"Loaded {len(locations)} locations: {locations}")
        
        # Create action server
        self._action_server = ActionServer(
            self,
            NavigateToLocation,
            'navigate_to_location',
            self.execute_callback
        )
        
        # Create Nav2 action client
        self._nav2_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        
        # Store current goal handle and pose for feedback calculation
        self._current_goal_handle = None
        self._current_target_pose = None
        
        self.get_logger().info('NavigateToLocation action server started')
    
    def execute_callback(self, goal_handle):
        """Execute callback for the action server."""
        location_name = goal_handle.request.location_name
        self.get_logger().info(f'Received goal to navigate to: {location_name}')
        
        # Get location pose
        pose = self.location_manager.get_location(location_name)
        if pose is None:
            result = NavigateToLocation.Result()
            result.success = False
            result.message = f"Location '{location_name}' not found. Available locations: {self.location_manager.list_locations()}"
            goal_handle.abort()
            return result
        
        # Wait for Nav2 action server
        self.get_logger().info('Waiting for Nav2 action server...')
        if not self._nav2_client.wait_for_server(timeout_sec=10.0):
            result = NavigateToLocation.Result()
            result.success = False
            result.message = "Nav2 action server not available"
            goal_handle.abort()
            return result
        
        # Create Nav2 goal
        nav2_goal_msg = NavigateToPose.Goal()
        nav2_goal_msg.pose = pose
        nav2_goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        
        # Store current goal handle and target pose for feedback
        self._current_goal_handle = goal_handle
        self._current_target_pose = pose
        
        # Send goal to Nav2
        self.get_logger().info(f'Sending goal to Nav2: {pose.pose.position.x}, {pose.pose.position.y}')
        send_goal_future = self._nav2_client.send_goal_async(
            nav2_goal_msg,
            feedback_callback=self.nav2_feedback_callback
        )
        
        # Wait for goal to be accepted
        rclpy.spin_until_future_complete(self, send_goal_future)
        goal_handle_nav2 = send_goal_future.result()
        
        if not goal_handle_nav2.accepted:
            result = NavigateToLocation.Result()
            result.success = False
            result.message = "Nav2 rejected the goal"
            goal_handle.abort()
            return result
        
        self.get_logger().info('Nav2 goal accepted, navigating...')
        
        # Publish initial feedback
        feedback_msg = NavigateToLocation.Feedback()
        feedback_msg.status = "Navigating to location..."
        feedback_msg.distance_remaining = 0.0
        goal_handle.publish_feedback(feedback_msg)
        
        # Wait for result
        get_result_future = goal_handle_nav2.get_result_async()
        
        # Periodically check for result and publish feedback
        while rclpy.ok():
            rclpy.spin_once(self, timeout_sec=0.1)
            
            if get_result_future.done():
                try:
                    response = get_result_future.result()
                    nav2_result = response.result
                    
                    # Create result based on Nav2 result
                    result = NavigateToLocation.Result()

                    if response.status == GoalStatus.STATUS_SUCCEEDED:
                        result.success = True
                        result.message = f"Successfully reached {location_name}"
                        self.get_logger().info(f"Successfully navigated to {location_name}")
                        goal_handle.succeed()
                        # Clear stored references
                        self._current_goal_handle = None
                        self._current_target_pose = None
                    else:
                        result.success = False
                        result.message = f"Failed to reach {location_name}. Nav2 status: {response.status}"
                        self.get_logger().warn(f"Failed to navigate to {location_name}")
                        goal_handle.abort()
                        # Clear stored references
                        self._current_goal_handle = None
                        self._current_target_pose = None

                    return result
                except Exception as e:
                    result = NavigateToLocation.Result()
                    result.success = False
                    result.message = f"Error during navigation: {str(e)}"
                    self.get_logger().error(f"Error: {e}")
                    goal_handle.abort()
                    # Clear stored references
                    self._current_goal_handle = None
                    self._current_target_pose = None
                    return result
            
            # Check if goal was cancelled
            if goal_handle.is_cancel_requested:
                self.get_logger().info('Goal cancelled')
                goal_handle_nav2.cancel_goal()
                result = NavigateToLocation.Result()
                result.success = False
                result.message = "Goal cancelled by user"
                goal_handle.canceled()
                # Clear stored references
                self._current_goal_handle = None
                self._current_target_pose = None
                return result
        
        # Should not reach here
        self._current_goal_handle = None
        self._current_target_pose = None
        result = NavigateToLocation.Result()
        result.success = False
        result.message = "Unexpected error"
        goal_handle.abort()
        return result
    
    def nav2_feedback_callback(self, feedback_msg):
        """Callback for Nav2 feedback to update our action feedback."""
        if self._current_goal_handle is None or self._current_target_pose is None:
            return
        
        # Calculate distance remaining from current pose to target
        nav2_feedback = feedback_msg.feedback
        current_pose = nav2_feedback.current_pose
        
        if current_pose and self._current_target_pose:
            dx = current_pose.pose.position.x - self._current_target_pose.pose.position.x
            dy = current_pose.pose.position.y - self._current_target_pose.pose.position.y
            distance = (dx**2 + dy**2)**0.5
            
            # Publish feedback to our action client
            feedback = NavigateToLocation.Feedback()
            feedback.status = f"Navigating to location... Distance: {distance:.2f}m"
            feedback.distance_remaining = distance
            self._current_goal_handle.publish_feedback(feedback)


def main(args=None):
    rclpy.init(args=args)
    
    action_server = NavigateToLocationActionServer()
    
    try:
        rclpy.spin(action_server)
    except KeyboardInterrupt:
        pass
    finally:
        action_server.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()

